<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>Apple Game</title>
    <style>
      :root {
        --num-rows: 10;
        --num-cols: 17;
        --duration: 120;

        /* 크기 관련 변수 */
        --board-width: min(94vw, 700px);
        --bw: clamp(6px, 1vw, 8px); /* 보더 두께 */
        --pad: clamp(10px, 1.6vw, 15px); /* 패딩 */
        /* 콘텐츠(그리드) 영역의 가로 폭 */
        --content-w: calc(var(--board-width) - (2 * (var(--bw) + var(--pad))));
        /* 한 셀 크기 */
        --cell: calc(var(--content-w) / var(--num-cols));
        /* 보드의 총 높이 = 콘텐츠 높이 + 상하 보더/패딩 */
        --board-height: calc(
          (var(--cell) * var(--num-rows)) + (2 * (var(--bw) + var(--pad)))
        );

        --color-text: #533;
        --color-bg: #f4f1ed;
        --color-apple-bg-selected: #2699e9;
        --color-apple-icon: #e21b1b;
        --color-apple-icon-selected: #f3e047;
        --color-board-border: #d49c42;
        --color-board-bg: #f3e047;
        --color-progress-bg: var(--color-text);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial,
          'Apple SD Gothic Neo', 'Noto Sans KR', sans-serif;
        color: var(--color-text);
        -webkit-tap-highlight-color: transparent;
      }
      body {
        padding: 12px 0 24px;
        background: var(--color-bg);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }
      h1 {
        font-size: clamp(18px, 5vw, 28px);
      }

      /* 상단 HUD */
      #controls {
        width: var(--board-width);
        display: flex;
        align-items: center;
        gap: 12px;
      }
      #score {
        flex-shrink: 0;
        position: relative;
        width: clamp(44px, 9vw, 64px);
        height: clamp(44px, 9vw, 64px);
        transform: translateY(-4px);
      }
      #score path {
        fill: var(--color-apple-icon);
      }
      #score span {
        position: absolute;
        inset: 6px 0 0 0;
        display: grid;
        place-items: center;
        font-weight: 800;
        font-size: clamp(16px, 4.2vw, 26px);
        color: #fff;
      }
      #progress {
        flex: 1 1 auto;
        height: clamp(18px, 3.2vw, 26px);
        background: var(--color-progress-bg);
        border: var(--bw) solid var(--color-board-border);
        border-radius: 12px;
        overflow: hidden;
      }
      #progress > div {
        width: 100%;
        height: 100%;
        background: var(--color-board-bg);
      }
      #progress > div.playing {
        transform: scaleX(0);
        transform-origin: left center;
        transition: transform calc(var(--duration) * 1s) linear;
      }
      #start {
        flex-shrink: 0;
        padding: clamp(8px, 1.4vw, 10px) clamp(10px, 2vw, 14px);
        background: var(--color-progress-bg);
        color: #fff;
        border: 0;
        border-radius: 12px;
        font-size: clamp(14px, 3.6vw, 18px);
        font-weight: 800;
        cursor: pointer;
      }

      #control2 {
        width: var(--board-width);
        display: flex;
        gap: 10px;
        align-items: center;
      }
      #remain-collect {
        font-weight: 800;
        font-size: clamp(14px, 3.8vw, 18px);
      }
      #auto-collect {
        margin-left: auto;
        padding: 8px 12px;
        background: var(--color-progress-bg);
        color: #fff;
        border: 0;
        border-radius: 10px;
        font-size: clamp(13px, 3.6vw, 17px);
        font-weight: 800;
        cursor: pointer;
      }

      /* 랭킹 + 보드 */
      #rank-board {
        width: var(--board-width);
        display: flex;
        gap: 12px;
        align-items: flex-start;
      }
      #ranking {
        flex: 0 0 clamp(140px, 28vw, 220px);
        font-weight: 800;
        font-size: clamp(14px, 3.8vw, 18px);
        display: none;
      }

      /* 보드 */
      #board {
        position: relative;
        width: var(--board-width);
        height: var(--board-height);
        padding: var(--pad);
        border: var(--bw) solid var(--color-board-border);
        border-radius: 12px;
        background: var(--color-board-bg);
        display: grid;
        grid-template-rows: repeat(var(--num-rows), var(--cell));
        grid-template-columns: repeat(var(--num-cols), var(--cell));
        gap: 0;
        touch-action: none;
      }
      #board * {
        user-select: none;
      }

      .apple {
        position: relative;
      }
      /* 아이콘을 셀 안쪽에 살짝 여백(시각적 중심 보정) */
      .apple svg {
        margin: 1px;
        width: calc(100% - 2px);
        height: calc(100% - 2px);
        display: block;
      }
      .apple path {
        fill: var(--color-apple-icon);
      }
      .apple span {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        font-weight: 800;
        font-size: calc(var(--cell) / 2);
        color: #fff;
        transform: translateY(6%);
      }

      .apple.selected {
        background: var(--color-apple-bg-selected);
      }
      .apple.selected path {
        fill: var(--color-apple-icon-selected);
      }
      .apple.selected span {
        color: var(--color-text);
      }

      .apple.collected svg {
        opacity: 0;
        transform: scale(2);
        transition: opacity 300ms, transform 300ms;
      }
      .apple.collected span {
        opacity: 0;
        transition: opacity 300ms;
      }

      /* 드래그 선택 박스 (패딩박스 기준) */
      #drag-rect {
        position: absolute;
        left: 0;
        top: 0;
        width: 0;
        height: 0;
        border: 2px dashed #2699e9;
        border-radius: 6px;
        background: rgba(38, 153, 233, 0.12);
        pointer-events: none;
        display: none;
      }

      #final-score {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        font-weight: 800;
        font-size: clamp(72px, 18vw, 200px);
      }

      #board:not(.playing) .apple {
        opacity: 0.7;
      }
      #board:not(.playing) .apple span {
        opacity: 0;
      }
      #board:not(.playing) #final-score {
        z-index: 2;
        opacity: 1;
        transform: scale(1);
        transition: opacity 350ms, transform 350ms;
        visibility: visible;
      }
      #board.playing .apple:hover {
        cursor: pointer;
      }
      #board.playing #final-score {
        z-index: -1;
        opacity: 0;
        transform: scale(0.95);
        visibility: hidden;
      }

      @media (max-width: 860px) {
        #rank-board {
          flex-direction: column;
        }
      }

      /* === 랭킹 모달 === */
      #ranking-overlay {
        color: white;
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        z-index: 998;
      }
      #ranking-modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(92vw, 420px);
        max-height: 80vh;
        overflow: auto;
        background: #222;
        color: #fff;
        padding: 18px 16px;
        border-radius: 14px;
        box-shadow: 0 0 12px rgba(255, 255, 255, 0.25);
        z-index: 999;
        text-align: left;
      }
      #ranking-modal h3 {
        margin: 0 0 10px;
        font-size: clamp(16px, 4.2vw, 20px);
      }
      #ranking-modal ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      #ranking-modal li {
        color: white;
        margin: 6px 0;
        font-size: clamp(14px, 3.8vw, 18px);
      }
      #modal-actions {
        display: flex;
        gap: 8px;
        justify-content: center;
        margin-top: 14px;
      }
      .btn {
        padding: 10px 18px;
        border: none;
        border-radius: 10px;
        background: #4caf50;
        color: #fff;
        font-size: clamp(14px, 3.8vw, 18px);
        cursor: pointer;
      }
      .btn.secondary {
        background: #555;
      }
    </style>
  </head>

  <body>
    <h1>Apple Game</h1>

    <div id="controls">
      <div id="score">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
          <path
            style="fill: #6b6b6b"
            d="M110.291,16.528c0,0,105.156-28.254,133.495,65.21C243.785,81.738,170.185,125.652,110.291,16.528z"
          />
          <path
            d="M238.343,169.456c-1.457-3.58-34.538-88.393,45.793-169.456l22.745,22.534c-65.016,65.614-39.904,132.172-38.809,134.969	L238.343,169.456z"
          />
          <path
            d="M360.196,109.621c-55.927,2.03-87.668,36.526-104.171,36.526s-48.244-34.496-104.171-36.526	C95.928,107.591,0.021,149.728,0.021,279.254S104.209,512,157.549,512s71.915-15.163,98.451-15.163S301.085,512,354.451,512	s157.528-103.227,157.528-232.746S416.123,107.591,360.196,109.621z"
          />
        </svg>
        <span></span>
      </div>
      <div id="progress"><div></div></div>
      <button id="start">start</button>
    </div>

    <div id="control2">
      <div id="remain-collect">현재 남은 조합은 : 0 개</div>
      <button id="auto-collect">조합 지우기</button>
    </div>

    <div id="rank-board">
      <div id="ranking">랭킹</div>
      <div id="board">
        <div id="drag-rect"></div>
        <h2 id="final-score"></h2>
      </div>
    </div>

    <svg
      id="apple-icon"
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 512 512"
    >
      <path
        style="fill: #6b6b6b"
        d="M110.291,16.528c0,0,105.156-28.254,133.495,65.21C243.785,81.738,170.185,125.652,110.291,16.528z"
      />
      <path
        d="M238.343,169.456c-1.457-3.58-34.538-88.393,45.793-169.456l22.745,22.534c-65.016,65.614-39.904,132.172-38.809,134.969	L238.343,169.456z"
      />
      <path
        d="M360.196,109.621c-55.927,2.03-87.668,36.526-104.171,36.526s-48.244-34.496-104.171-36.526	C95.928,107.591,0.021,149.728,0.021,279.254S104.209,512,157.549,512s71.915-15.163,98.451-15.163S301.085,512,354.451,512	s157.528-103.227,157.528-232.746S416.123,107.591,360.196,109.621z"
      />
    </svg>

    <!-- 랭킹 모달 -->
    <div id="ranking-overlay"></div>
    <div id="ranking-modal">
      <h3>🏆 TOP 5 랭킹</h3>
      <ul id="ranking-list"></ul>
      <div id="modal-actions">
        <button id="modal-close" class="btn">계속하기</button>
      </div>
    </div>

    <!-- Firebase RTDB -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

    <script>
      // ===== Firebase =====
      const firebaseConfig = {
        apiKey: 'AIzaSyDL7ncBKn-NMy6xn1gswQ4VuIbZC8nNHPw',
        authDomain: 'applegame-fca32.firebaseapp.com',
        databaseURL:
          'https://applegame-fca32-default-rtdb.asia-southeast1.firebasedatabase.app',
        projectId: 'applegame-fca32',
        storageBucket: 'applegame-fca32.firebasestorage.app',
        messagingSenderId: '169315199964',
        appId: '1:169315199964:web:d99515ad4cf6ff7150bd19',
        measurementId: 'G-1YNQW1BVFS',
      };
      firebase.initializeApp(firebaseConfig);
      const db = firebase.database();

      // ===== 요소 =====
      const styles = getComputedStyle(document.documentElement);
      const numRows = parseInt(styles.getPropertyValue('--num-rows'));
      const numCols = parseInt(styles.getPropertyValue('--num-cols'));
      const duration = parseFloat(styles.getPropertyValue('--duration'));

      const $board = document.getElementById('board');
      const $dragRect = document.getElementById('drag-rect');
      const $score = document.querySelector('#score span');
      const $finalScore = document.getElementById('final-score');
      const $start = document.getElementById('start');
      const $progress = document.querySelector('#progress > div');
      const $remaincollect = document.getElementById('remain-collect');
      const $autocollect = document.getElementById('auto-collect');
      const $appleIcon = document.getElementById('apple-icon');

      // 랭킹 모달
      const rankingModal = document.getElementById('ranking-modal');
      const rankingOverlay = document.getElementById('ranking-overlay');
      const rankingList = document.getElementById('ranking-list');
      const modalCloseBtn = document.getElementById('modal-close');

      const $apples = [];
      let playing = false,
        dragging = false;
      let pos1 = null,
        pos2 = null;
      let score = 0,
        timerId = null;

      const nickname =
        (localStorage.getItem('nickname') || '').trim() || '익명';

      document.addEventListener('contextmenu', (e) => {
        if (e.target.closest('#board')) e.preventDefault();
      });

      init();

      function init() {
        // 보드 채우기 (셀 크기는 CSS가 계산)
        for (let row = 0; row < numRows; row++) {
          for (let col = 0; col < numCols; col++) {
            const $apple = document.createElement('div');
            $apple.className = 'apple';
            const $icon = document.importNode($appleIcon, true);
            $icon.removeAttribute('id');
            const $number = document.createElement('span');
            $apple.appendChild($icon);
            $apple.appendChild($number);
            $board.appendChild($apple);
            $apples.push($apple);
          }
        }
        $appleIcon.remove();

        $start.addEventListener('click', start, { passive: true });
        $autocollect.addEventListener('click', autocollect, { passive: true });

        // Pointer events
        $board.addEventListener('pointerdown', onPointerDown, {
          passive: false,
        });
        $board.addEventListener('pointermove', onPointerMove, {
          passive: false,
        });
        $board.addEventListener('pointerup', onPointerUp, { passive: false });
        $board.addEventListener('pointercancel', onPointerUp, {
          passive: false,
        });
        $board.addEventListener('lostpointercapture', onPointerUp, {
          passive: false,
        });

        // 모달 닫기
        rankingOverlay.addEventListener('click', () => closeModal());
        modalCloseBtn.addEventListener('click', () => closeModal());
      }

      // === 게임 흐름 ===
      function start() {
        playing = true;
        score = 0;
        $score.textContent = 0;
        $board.classList.add('playing');
        $start.textContent = 'reset';

        $progress.classList.remove('playing');
        void $progress.offsetWidth;
        $progress.classList.add('playing');
        if (timerId) clearTimeout(timerId);
        timerId = setTimeout(end, duration * 1000);

        for (const $a of $board.querySelectorAll('.collected'))
          $a.classList.remove('collected');
        for (const $a of $apples) {
          $a.querySelector('span').textContent =
            Math.floor(Math.random() * 9) + 1;
        }
        $remaincollect.textContent =
          '현재 남은 조합은 : ' + findcollect().length + ' 개';
      }

      async function end() {
        dragging = false;
        hideDragRect();
        clearSelection();
        playing = false;
        $board.classList.remove('playing');
        $start.textContent = 'start';
        $finalScore.textContent = score;
        beep(true);

        try {
          await saveScoreToFirebase(score);
        } catch (e) {
          console.error('점수 저장 실패', e);
        }
        await showRankingModal();
      }

      // === 랭킹 저장/표시 ===
      function saveScoreToFirebase(score) {
        const ref = db.ref('records').push();
        return ref.set({ name: nickname, score, timestamp: Date.now() });
      }
      async function showRankingModal() {
        try {
          const snap = await db
            .ref('records')
            .orderByChild('score')
            .limitToLast(100)
            .once('value');
          const raw = snap.val();
          const data = raw ? Object.values(raw) : [];
          const sorted = data.sort((a, b) => b.score - a.score).slice(0, 5);
          rankingList.innerHTML = '';
          if (sorted.length === 0) {
            rankingList.innerHTML = '<li>랭킹 기록 없음</li>';
          } else {
            sorted.forEach((r, i) => {
              const li = document.createElement('li');
              li.textContent = `${i + 1}위 - ${r.name}: ${r.score}점`;
              rankingList.appendChild(li);
            });
          }
        } catch (e) {
          console.error(e);
          rankingList.innerHTML = '<li>랭킹을 불러오지 못했어요</li>';
        }
        rankingOverlay.style.display = 'block';
        rankingModal.style.display = 'block';
      }
      function closeModal() {
        rankingModal.style.display = 'none';
        rankingOverlay.style.display = 'none';
        start();
      }

      // === 보더/패딩 보정 메트릭 ===
      function getGridMetrics() {
        const rect = $board.getBoundingClientRect();
        const cs = getComputedStyle($board);
        const padL = parseFloat(cs.paddingLeft) || 0;
        const padT = parseFloat(cs.paddingTop) || 0;
        const padR = parseFloat(cs.paddingRight) || 0;
        const padB = parseFloat(cs.paddingBottom) || 0;
        const borL = parseFloat(cs.borderLeftWidth) || 0;
        const borT = parseFloat(cs.borderTopWidth) || 0;
        const borR = parseFloat(cs.borderRightWidth) || 0;
        const borB = parseFloat(cs.borderBottomWidth) || 0;
        const contentW = rect.width - borL - borR - padL - padR;
        const contentH = rect.height - borT - borB - padT - padB;
        const originX = rect.left + borL + padL;
        const originY = rect.top + borT + padT;
        const cellW = contentW / numCols;
        const cellH = contentH / numRows;
        return {
          contentW,
          contentH,
          originX,
          originY,
          cellW,
          cellH,
          padL,
          padT,
        };
      }

      // === 포인터/드래그 ===
      function getCellFromPointer(ev) {
        const m = getGridMetrics();
        const x = ev.clientX - m.originX;
        const y = ev.clientY - m.originY;
        if (x < 0 || y < 0 || x > m.contentW || y > m.contentH) return null;
        const col = Math.min(numCols - 1, Math.max(0, Math.floor(x / m.cellW)));
        const row = Math.min(numRows - 1, Math.max(0, Math.floor(y / m.cellH)));
        return [row, col];
      }
      function updateDragRect() {
        if (!dragging || !pos1 || !pos2) {
          hideDragRect();
          return;
        }
        const m = getGridMetrics();
        const minRow = Math.min(pos1[0], pos2[0]);
        const maxRow = Math.max(pos1[0], pos2[0]);
        const minCol = Math.min(pos1[1], pos2[1]);
        const maxCol = Math.max(pos1[1], pos2[1]);

        const left = m.padL + minCol * m.cellW;
        const top = m.padT + minRow * m.cellH;
        const width = (maxCol - minCol + 1) * m.cellW;
        const height = (maxRow - minRow + 1) * m.cellH;

        const s = $dragRect.style;
        s.display = 'block';
        s.left = Math.round(left) + 'px';
        s.top = Math.round(top) + 'px';
        s.width = Math.round(width) + 'px';
        s.height = Math.round(height) + 'px';
      }
      function hideDragRect() {
        $dragRect.style.display = 'none';
      }

      function onPointerDown(ev) {
        if (!playing) return;
        ev.preventDefault();
        const cell = getCellFromPointer(ev);
        if (!cell) return;
        dragging = true;
        $board.setPointerCapture(ev.pointerId);
        pos1 = cell;
        pos2 = cell;
        drawSelection();
        updateDragRect();
      }
      function onPointerMove(ev) {
        if (!playing || !dragging) return;
        ev.preventDefault();
        const cell = getCellFromPointer(ev);
        if (!cell) return;
        const [r, c] = cell;
        if (!pos2 || r !== pos2[0] || c !== pos2[1]) {
          pos2 = cell;
          drawSelection();
          updateDragRect();
        }
      }
      function onPointerUp(ev) {
        if (!playing) return;
        ev.preventDefault();
        if (!dragging) return;
        dragging = false;
        collect();
        clearSelection();
        hideDragRect();
      }

      // === 선택/수집 ===
      function drawSelection() {
        clearSelection();
        const minRow = Math.min(pos1[0], pos2[0]);
        const maxRow = Math.max(pos1[0], pos2[0]);
        const minCol = Math.min(pos1[1], pos2[1]);
        const maxCol = Math.max(pos1[1], pos2[1]);
        for (let r = minRow; r <= maxRow; r++) {
          for (let c = minCol; c <= maxCol; c++) {
            $apples[r * numCols + c].classList.add('selected');
          }
        }
      }
      function clearSelection() {
        for (const $a of $board.querySelectorAll('.apple.selected'))
          $a.classList.remove('selected');
      }
      function collect() {
        let sum = 0;
        const $selected = $board.querySelectorAll(
          '.apple.selected:not(.collected)'
        );
        for (const $a of $selected) sum += Number($a.textContent);
        if (sum !== 10) return;
        for (const $a of $selected) {
          $a.querySelector('span').textContent = 'bomb';
          $a.classList.add('collected');
        }
        score += $selected.length;
        $score.textContent = score;
        const left = findcollect().length;
        $remaincollect.textContent = `현재 남은 조합은 : ${left} 개`;
        if (left === 0) end();
        beep();
      }

      // === 효과음 ===
      function beep(long = false) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        try {
          const ctx = new Ctx();
          const osc = ctx.createOscillator();
          osc.frequency.value = 400;
          osc.connect(ctx.destination);
          osc.start();
          osc.stop(ctx.currentTime + (long ? 1 : 0.1));
        } catch (_) {}
      }

      // === 남은 조합 ===
      function findcollect() {
        const combos = [];
        for (let sr = 0; sr < numRows; sr++) {
          for (let sc = 0; sc < numCols; sc++) {
            for (let er = sr; er < numRows; er++) {
              for (let ec = sc; ec < numCols; ec++) {
                let sum = 0;
                for (let r = sr; r <= er; r++) {
                  for (let c = sc; c <= ec; c++) {
                    const n = Number($apples[r * numCols + c].textContent);
                    if (!Number.isNaN(n)) sum += n;
                  }
                }
                if (sum === 10)
                  combos.push({
                    start: { row: sr, col: sc },
                    end: { row: er, col: ec },
                  });
              }
            }
          }
        }
        return combos;
      }

      // === 자동 수집 ===
      function autocollect() {
        const combos = findcollect();
        if (combos.length === 0) {
          alert('지울 수 있는 조합이 없어요!');
          return;
        }
        const pick = combos[Math.floor(Math.random() * combos.length)];
        pos1 = [pick.start.row, pick.start.col];
        pos2 = [pick.end.row, pick.end.col];
        drawSelection();
        updateDragRect();
        collect();
        clearSelection();
        hideDragRect();
      }
    </script>
  </body>
</html>
