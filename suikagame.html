<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <!-- Î™®Î∞îÏùº ÌôïÎåÄ Î∞©ÏßÄ & Î∞òÏùëÌòï -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>ÏàòÎ∞ï Í≤åÏûÑ üçâ</title>
    <style>
      :root {
        --max-canvas-w: 420px;
      }
      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: #222;
        color: #fff;
        font-family: Arial, sans-serif;
        text-align: center;
        overflow-x: hidden;
      }
      h1 {
        font-size: clamp(18px, 4vw, 24px);
        margin: 12px 8px 4px;
      }
      #hud {
        margin: 0 auto;
        width: min(92vw, var(--max-canvas-w));
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      #score {
        font-size: clamp(16px, 3.8vw, 20px);
      }
      #game {
        display: block;
        margin: 10px auto 16px;
        width: min(92vw, var(--max-canvas-w));
        aspect-ratio: 9 / 16;
        background: #333;
        border: 4px solid #4caf50;
        border-radius: 16px;
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
      }
      #gameOver {
        color: tomato;
        font-size: clamp(16px, 4vw, 22px);
        margin-top: 6px;
        display: none;
      }

      /* Îû≠ÌÇπ Î™®Îã¨ */
      #ranking-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        z-index: 998;
      }
      #ranking-modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(92vw, 420px);
        max-height: 80vh;
        overflow: auto;
        background: #222;
        padding: 18px 16px;
        border-radius: 14px;
        box-shadow: 0 0 12px rgba(255, 255, 255, 0.25);
        z-index: 999;
        text-align: left;
      }
      #ranking-modal h3 {
        margin: 0 0 10px;
        font-size: clamp(16px, 4.2vw, 20px);
      }
      #ranking-modal ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      #ranking-modal li {
        margin: 6px 0;
        font-size: clamp(14px, 3.8vw, 18px);
      }
      #modal-actions {
        display: flex;
        gap: 8px;
        justify-content: center;
        margin-top: 14px;
      }
      .btn {
        padding: 10px 18px;
        border: none;
        border-radius: 10px;
        background: #4caf50;
        color: #fff;
        font-size: clamp(14px, 3.8vw, 18px);
        cursor: pointer;
      }
      .btn.secondary {
        background: #555;
      }
    </style>

    <!-- Firebase (Compat) -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  </head>
  <body>
    <h1>ÏàòÎ∞ï Í≤åÏûÑ üçâ</h1>

    <div id="hud">
      <div id="score">Ï†êÏàò: 0</div>
    </div>

    <canvas id="game"></canvas>
    <div id="gameOver">GAME OVER</div>

    <!-- Îû≠ÌÇπ Î™®Îã¨ -->
    <div id="ranking-overlay"></div>
    <div id="ranking-modal">
      <h3>üèÜ TOP 5 Îû≠ÌÇπ</h3>
      <ul id="ranking-list"></ul>
      <div id="modal-actions">
        <button id="modal-close" class="btn">Í≥ÑÏÜçÌïòÍ∏∞</button>
      </div>
    </div>

    <script>
      // ================= Firebase =================
      const firebaseConfig = {
        apiKey: 'AIzaSyAhkw341lTuMueuSP5JwycuUUwdpbOvPpc',
        authDomain: 'suikagame-2dc1e.firebaseapp.com',
        databaseURL:
          'https://suikagame-2dc1e-default-rtdb.asia-southeast1.firebasedatabase.app',
        projectId: 'suikagame-2dc1e',
        storageBucket: 'suikagame-2dc1e.firebasestorage.app',
        messagingSenderId: '96745545055',
        appId: '1:96745545055:web:9f5a8ad4bad5cf1240aaea',
        measurementId: 'G-3PQE9DEXGX',
      };
      firebase.initializeApp(firebaseConfig);
      const db = firebase.database();

      // ================= Í∏∞Î≥∏ ÏÑ§Ï†ï =================
      const BASE_W = 360,
        BASE_H = 640;

      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      function setupCanvasForDPR() {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        canvas.width = Math.floor(BASE_W * dpr);
        canvas.height = Math.floor(BASE_H * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
      }
      setupCanvasForDPR();
      window.addEventListener('resize', setupCanvasForDPR);
      window.addEventListener('orientationchange', () =>
        setTimeout(setupCanvasForDPR, 100)
      );

      const scoreDiv = document.getElementById('score');
      const gameOverDiv = document.getElementById('gameOver');
      const rankingModal = document.getElementById('ranking-modal');
      const rankingOverlay = document.getElementById('ranking-overlay');
      const rankingList = document.getElementById('ranking-list');
      const modalCloseBtn = document.getElementById('modal-close');

      const dangerLine = BASE_H / 5;
      const nickname = localStorage.getItem('nickname') || 'ÏùµÎ™Ö';

      // ================= Í≥ºÏùº Îç∞Ïù¥ÌÑ∞/Ïù¥ÎØ∏ÏßÄ =================
      const fruitData = [
        { name: 'cherry', radius: 20, score: 10 },
        { name: 'grape', radius: 44, score: 20 },
        { name: 'korean melon', radius: 69, score: 40 },
        { name: 'strawberry', radius: 85, score: 80 },
        { name: 'grape fruit', radius: 91, score: 160 },
        { name: 'watermelon', radius: 130, score: 320 },
      ];
      const charSet = localStorage.getItem('set') === 'B' ? 'yoon' : 'co';
      const fruitImages = {};
      let assetsLoaded = 0;
      fruitData.forEach((f) => {
        const img = new Image();
        img.src = `${f.name}_${charSet}.png`;
        img.onload = () => {
          assetsLoaded++;
          if (assetsLoaded === fruitData.length) startGame();
        };
        fruitImages[f.name] = img;
      });

      // ================= Í≤åÏûÑ ÏÉÅÌÉú =================
      let fruits = [];
      let fallingFruit = null;
      let gameOver = false;
      let score = 0;
      let rafId = null;

      // ================= Î¨ºÎ¶¨ ÌååÎùºÎØ∏ÌÑ∞ =================
      const GRAVITY = 1200 / 3600; // px/frame^2 (Í≥†Ï†ïÌÉÄÏûÑÏä§ÌÖù Í∏∞Ï§Ä)
      const FIXED_DT = 1 / 60; // 60Hz
      const SOLVER_ITERS = 8; // Ï°∞Í∏à Îçî Í∞ïÌïòÍ≤å
      const RESTITUTION = 0.02;
      const FRICTION = 0.05;
      const SLEEP_SPEED = 5 / 60;
      const SLEEP_TIME = 0.25;
      const PENETRATION_SLOP = 0.5;
      const POSITION_CORRECT = 0.6;

      // ====== Ìï©Ï≤¥ ÏÑ§Ï†ï(Ïó∞ÏÜç Ï†ëÏ¥â Í∏∞Î∞ò) ======
      const MERGE_HOLD_THRESHOLD = 0.05; // 0.05Ï¥à Ïó∞ÏÜç Ï†ëÏ¥â Ïãú Ìï©Ï≤¥
      let FRUIT_SEQ = 0;

      function createFruit(level, x, y) {
        const d = fruitData[level];
        return {
          id: FRUIT_SEQ++,
          x,
          y,
          vx: 0,
          vy: 0,
          radius: d.radius,
          level,
          alive: true,
          settled: false,
          sleepTimer: 0,
          mergeHold: 0, // Í∞ôÏùÄ Î†àÎ≤®Í≥º Ïó∞ÏÜç Ï†ëÏ¥â ÎàÑÏ†ÅÏãúÍ∞Ñ(Ï¥à)
        };
      }
      function wake(f) {
        f.settled = false;
        f.sleepTimer = 0;
      }
      function clampPosition(f) {
        f.x = Math.max(f.radius, Math.min(BASE_W - f.radius, f.x));
        f.y = Math.max(f.radius, Math.min(BASE_H - f.radius, f.y));
        if (f.settled && f.y + f.radius > BASE_H) f.y = BASE_H - f.radius;
      }

      // ================= ÏûÖÎ†•(ÌÑ∞Ïπò/ÎßàÏö∞Ïä§) =================
      function getCanvasXFromEvent(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.clientX ?? (e.touches && e.touches[0]?.clientX) ?? 0;
        const relX = clientX - rect.left;
        return (relX / rect.width) * BASE_W; // ÌôîÎ©¥ ÌîΩÏÖÄ -> ÎÖºÎ¶¨ Ï¢åÌëú
      }
      canvas.addEventListener(
        'pointermove',
        (e) => {
          if (!fallingFruit || gameOver) return;
          e.preventDefault();
          const x = getCanvasXFromEvent(e);
          const r = fallingFruit.radius;
          fallingFruit.x = Math.max(r, Math.min(BASE_W - r, x));
        },
        { passive: false }
      );
      canvas.addEventListener(
        'pointerdown',
        (e) => {
          if (fallingFruit && !gameOver) {
            e.preventDefault();
            fruits.push({ ...fallingFruit });
            fallingFruit = null;
            spawnNext();
          }
        },
        { passive: false }
      );
      canvas.addEventListener('contextmenu', (e) => e.preventDefault());
      document.addEventListener(
        'touchmove',
        (e) => {
          if (e.target === canvas) e.preventDefault();
        },
        { passive: false }
      );

      function spawnNext() {
        if (gameOver) return;
        const lvl = Math.floor(Math.random() * 2); // 0~1 Î†àÎ≤®Îßå
        fallingFruit = createFruit(lvl, BASE_W / 2, 40);
      }

      // ================= Î¨ºÎ¶¨ Ï≤òÎ¶¨ =================
      function applyGravity(f) {
        if (!f.alive || f.settled) return;
        f.vy += GRAVITY;

        // Ï∂îÍ∞Ä: Í≥µÍ∏∞ Ï†ÄÌï≠
        f.vx *= 0.985; // Í∞ÄÎ°úÏÜçÎèÑ ÏÑúÏÑúÌûà Ï§ÑÏù¥Í∏∞
        f.vy *= 0.995; // ÏÑ∏Î°úÏÜçÎèÑ ÏÇ¥Ïßù Ï§ÑÏù¥Í∏∞
      }
      function integrate(f) {
        if (!f.alive || f.settled) return;
        f.x += f.vx;
        f.y += f.vy;
      }
      function solveWalls(f) {
        if (!f.alive) return;
        if (f.x - f.radius < 0) {
          f.x = f.radius;
          f.vx = 0;
        } else if (f.x + f.radius > BASE_W) {
          f.x = BASE_W - f.radius;
          f.vx = 0;
        }
        if (f.y + f.radius > BASE_H) {
          const pen = f.y + f.radius - BASE_H;
          f.y -= pen;
          f.vy = -f.vy * RESTITUTION;
          f.vx *= 1 - FRICTION;
          if (Math.abs(f.vy) < SLEEP_SPEED) f.vy = 0;
          if (Math.abs(f.vx) < SLEEP_SPEED) f.vx = 0;
        }
        if (f.y - f.radius < 0) {
          f.y = f.radius;
          f.vy = 0;
        }
      }
      function solvePair(a, b) {
        if (!a.alive || !b.alive) return;
        const dx = b.x - a.x,
          dy = b.y - a.y;
        const dist = Math.hypot(dx, dy);
        const minDist = a.radius + b.radius;
        if (dist >= minDist) return;

        const nx = dx / (dist || 1),
          ny = dy / (dist || 1);
        const tx = -ny,
          ty = nx;

        const rvx = b.vx - a.vx,
          rvy = b.vy - a.vy;
        const vrelN = rvx * nx + rvy * ny;
        const vrelT = rvx * tx + rvy * ty;

        let jn = (-(1 + RESTITUTION) * vrelN) / 2;
        if (jn < 0) jn = 0;
        let jt = -vrelT * FRICTION;

        a.vx -= jn * nx + jt * tx;
        a.vy -= jn * ny + jt * ty;
        b.vx += jn * nx + jt * tx;
        b.vy += jn * ny + jt * ty;

        const penetration = Math.max(0, minDist - dist - PENETRATION_SLOP);
        const corr = (penetration * POSITION_CORRECT) / 2;
        a.x -= nx * corr;
        a.y -= ny * corr;
        b.x += nx * corr;
        b.y += ny * corr;

        wake(a);
        wake(b);
      }
      function updateSleep(f, dt) {
        if (!f.alive) return;
        const speed = Math.hypot(f.vx, f.vy);
        const onGround = f.y + f.radius >= BASE_H - 0.5;
        if (speed < SLEEP_SPEED && (onGround || f.settled)) {
          f.sleepTimer += dt;
          if (f.sleepTimer >= SLEEP_TIME) {
            f.vx = 0;
            f.vy = 0;
            f.settled = true;
          }
        } else {
          f.sleepTimer = 0;
          f.settled = false;
        }
      }

      // ====== ‚ÄúÍ∞ôÏùÄ Î†àÎ≤® Ï†ëÏ¥â‚Äù ÌåêÏ†ï + ÎàÑÏ†Å ======
      function isSameLevelInContact(a, b) {
        if (!a.alive || !b.alive) return false;
        if (a.level !== b.level) return false;
        const dx = b.x - a.x,
          dy = b.y - a.y;
        const dist = Math.hypot(dx, dy);
        const minDist = a.radius + b.radius;

        // ÌôïÏã§Ìïú Í≤πÏπ®
        if (dist <= minDist - 0.25) return true;

        // Í±∞Ïùò ÎãøÏïÑ ÏûàÎäî ÏÉÅÌÉú + ÏÉÅÎåÄÏÜçÎèÑ Îß§Ïö∞ ÎÇÆÏùå ‚Üí Ï†ëÏ¥âÏúºÎ°ú Í∞ÑÏ£º
        const relSpeed = Math.hypot(b.vx - a.vx, b.vy - a.vy);
        if (dist <= minDist + 0.6 && relSpeed < 6 / 60) return true;

        return false;
      }
      function updateMergeHolds(dt) {
        for (const f of fruits) {
          if (!f.alive) continue;
          // Îñ®Ïñ¥ÏßÄÎ©¥ ÏÑúÏÑúÌûà Í∞êÏÜå(ÎÑàÎ¨¥ Îπ®Î¶¨ 0 ÎêòÏßÄ ÏïäÍ≤å)
          f.mergeHold = Math.max(0, f.mergeHold - dt * 0.25);
        }
        for (let i = 0; i < fruits.length; i++) {
          const a = fruits[i];
          if (!a.alive) continue;
          for (let j = i + 1; j < fruits.length; j++) {
            const b = fruits[j];
            if (!b.alive) continue;
            if (isSameLevelInContact(a, b)) {
              a.mergeHold += dt;
              b.mergeHold += dt;
            }
          }
        }
      }
      function tryMergeAll() {
        let merged = false;
        outer: for (let i = 0; i < fruits.length; i++) {
          const a = fruits[i];
          if (!a.alive || a.mergeHold < MERGE_HOLD_THRESHOLD) continue;

          for (let j = i + 1; j < fruits.length; j++) {
            const b = fruits[j];
            if (!b.alive || b.mergeHold < MERGE_HOLD_THRESHOLD) continue;
            if (!isSameLevelInContact(a, b)) continue;
            if (a.level !== b.level) continue;
            if (a.level >= fruitData.length - 1) continue;

            const mx = (a.x + b.x) / 2,
              my = (a.y + b.y) / 2;
            const nf = createFruit(a.level + 1, mx, my);
            const overlap =
              a.radius + b.radius - Math.hypot(b.x - a.x, b.y - a.y);
            nf.y -= Math.max(0, overlap) * 0.25; // Ï°∞Í∏à ÏúÑÎ°ú
            nf.vx = (a.vx + b.vx) * 0.25;
            nf.vy = (a.vy + b.vy) * 0.25;

            clampPosition(nf);
            fruits.push(nf);
            score += fruitData[a.level + 1].score;
            scoreDiv.textContent = `Ï†êÏàò: ${score}`;
            a.alive = false;
            b.alive = false;
            merged = true;
            break outer;
          }
        }
        if (merged) fruits = fruits.filter((f) => f.alive);
      }

      // ================= ÏúÑÌóòÏÑ† =================
      function isTouchingOthers(f, others) {
        return others.some(
          (o) =>
            o !== f &&
            o.alive &&
            Math.hypot(f.x - o.x, f.y - o.y) < f.radius + o.radius - 1
        );
      }
      function checkDangerLine() {
        return fruits.some(
          (f, _, arr) =>
            (f.settled || isTouchingOthers(f, arr)) &&
            f.y - f.radius < dangerLine + 0.5
        );
      }

      // ================= Î†åÎçî =================
      function drawFruit(f) {
        const img = fruitImages[fruitData[f.level].name];
        if (img && img.complete) {
          ctx.drawImage(
            img,
            f.x - f.radius,
            f.y - f.radius,
            f.radius * 2,
            f.radius * 2
          );
        } else {
          ctx.beginPath();
          ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
          ctx.fillStyle = '#ff0';
          ctx.fill();
        }
      }

      // ================= Î©îÏù∏ Î£®ÌîÑ(Í≥†Ï†ï ÌÉÄÏûÑÏä§ÌÖù) =================
      let lastTime = performance.now(),
        acc = 0;
      function loop(now = performance.now()) {
        const elapsed = Math.min(0.1, (now - lastTime) / 1000); // 100ms Ï∫°
        lastTime = now;
        acc += elapsed;

        while (acc >= FIXED_DT) {
          for (const f of fruits) applyGravity(f);
          for (const f of fruits) integrate(f);
          for (const f of fruits) solveWalls(f);

          // Ïõê-Ïõê Ï∂©Îèå Î∞òÎ≥µ Ìï¥Í≤∞
          for (let k = 0; k < SOLVER_ITERS; k++) {
            for (let i = 0; i < fruits.length; i++) {
              const a = fruits[i];
              if (!a.alive) continue;
              for (let j = i + 1; j < fruits.length; j++) {
                const b = fruits[j];
                if (!b.alive) continue;
                solvePair(a, b);
              }
            }
          }

          for (const f of fruits) updateSleep(f, FIXED_DT);

          // Ï†ëÏ¥âÏãúÍ∞Ñ ÎàÑÏ†Å ‚Üí Ìï©Ï≤¥ ÏãúÎèÑ
          updateMergeHolds(FIXED_DT);
          tryMergeAll();

          acc -= FIXED_DT;
        }

        // ---- Î†åÎçî ----
        ctx.clearRect(0, 0, BASE_W, BASE_H);
        ctx.save();
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, dangerLine);
        ctx.lineTo(BASE_W, dangerLine);
        ctx.stroke();
        ctx.restore();

        if (fallingFruit) {
          ctx.globalAlpha = 0.7;
          drawFruit(fallingFruit);
          ctx.globalAlpha = 1;
        }
        fruits.forEach(drawFruit);

        if (!gameOver) {
          if (checkDangerLine()) {
            gameOver = true;
            gameOverDiv.style.display = '';
            saveScoreToFirebase(score);
          } else {
            rafId = requestAnimationFrame(loop);
          }
        }
      }

      // ================= Ï†êÏàò Ï†ÄÏû•/Îû≠ÌÇπ =================
      function saveScoreToFirebase(score) {
        const newRef = db.ref('records').push();
        newRef
          .set({ name: nickname, score, timestamp: Date.now() })
          .then(showRankingModal)
          .catch(() => showRankingModal());
      }
      function showRankingModal() {
        db.ref('records')
          .orderByChild('score')
          .limitToLast(100)
          .once('value')
          .then((snapshot) => {
            const raw = snapshot.val();
            const data = raw ? Object.values(raw) : [];
            const sorted = data.sort((a, b) => b.score - a.score).slice(0, 5);

            rankingList.innerHTML = '';
            if (sorted.length === 0) {
              rankingList.innerHTML = '<li>Îû≠ÌÇπ Í∏∞Î°ù ÏóÜÏùå</li>';
            } else {
              sorted.forEach((r, i) => {
                const li = document.createElement('li');
                li.textContent = `${i + 1}ÏúÑ - ${r.name}: ${r.score}Ï†ê`;
                rankingList.appendChild(li);
              });
            }
            rankingOverlay.style.display = 'block';
            rankingModal.style.display = 'block';
          });
      }
      function closeModal(skipRestart = false) {
        rankingModal.style.display = 'none';
        rankingOverlay.style.display = 'none';
        if (!skipRestart) startGame();
      }
      rankingOverlay.addEventListener('click', () => closeModal());
      modalCloseBtn.addEventListener('click', () => closeModal());

      // ================= ÏãúÏûë =================
      function startGame() {
        fruits = [];
        score = 0;
        gameOver = false;
        fallingFruit = null;
        scoreDiv.textContent = `Ï†êÏàò: ${score}`;
        gameOverDiv.style.display = 'none';
        rankingModal.style.display = 'none';
        rankingOverlay.style.display = 'none';
        spawnNext();
        if (rafId) cancelAnimationFrame(rafId);
        lastTime = performance.now();
        acc = 0;
        rafId = requestAnimationFrame(loop);
      }
    </script>
  </body>
</html>
