<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>ÏàòÎ∞ï Í≤åÏûÑ üçâ</title>
    <style>
      :root {
        --max-canvas-w: 420px;
      }
      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: #222;
        color: #fff;
        font-family: Arial, sans-serif;
        text-align: center;
        overflow-x: hidden;
      }
      h1 {
        font-size: clamp(18px, 4vw, 24px);
        margin: 12px 8px 4px;
      }
      #hud {
        margin: 0 auto;
        width: min(92vw, var(--max-canvas-w));
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      #score {
        font-size: clamp(16px, 3.8vw, 20px);
      }
      #game {
        display: block;
        margin: 10px auto 16px;
        width: min(92vw, var(--max-canvas-w));
        aspect-ratio: 9/16;
        background: #333;
        border: 4px solid #4caf50;
        border-radius: 16px;
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
      }
      #gameOver {
        color: tomato;
        font-size: clamp(16px, 4vw, 22px);
        margin-top: 6px;
        display: none;
      }
      #ranking-overlay {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        z-index: 998;
      }
      #ranking-modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(92vw, 420px);
        max-height: 80vh;
        overflow: auto;
        background: #222;
        padding: 18px 16px;
        border-radius: 14px;
        box-shadow: 0 0 12px rgba(255, 255, 255, 0.25);
        z-index: 999;
        text-align: left;
      }
      #ranking-modal h3 {
        margin: 0 0 10px;
        font-size: clamp(16px, 4.2vw, 20px);
      }
      #ranking-modal ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      #ranking-modal li {
        margin: 6px 0;
        font-size: clamp(14px, 3.8vw, 18px);
      }
      #modal-actions {
        display: flex;
        gap: 8px;
        justify-content: center;
        margin-top: 14px;
      }
      .btn {
        padding: 10px 18px;
        border: none;
        border-radius: 10px;
        background: #4caf50;
        color: #fff;
        font-size: clamp(14px, 3.8vw, 18px);
        cursor: pointer;
      }
      .btn.secondary {
        background: #555;
      }
    </style>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  </head>
  <body>
    <h1>ÏàòÎ∞ï Í≤åÏûÑ üçâ</h1>
    <div id="hud"><div id="score">Ï†êÏàò: 0</div></div>
    <canvas id="game"></canvas>
    <div id="gameOver">GAME OVER</div>

    <div id="ranking-overlay"></div>
    <div id="ranking-modal">
      <h3>üèÜ TOP 5 Îû≠ÌÇπ</h3>
      <ul id="ranking-list"></ul>
      <div id="modal-actions">
        <button id="modal-close" class="btn">Í≥ÑÏÜçÌïòÍ∏∞</button>
      </div>
    </div>

    <script>
      // Firebase
      const firebaseConfig = {
        apiKey: 'AIzaSyAhkw341lTuMueuSP5JwycuUUwdpbOvPpc',
        authDomain: 'suikagame-2dc1e.firebaseapp.com',
        databaseURL:
          'https://suikagame-2dc1e-default-rtdb.asia-southeast1.firebasedatabase.app',
        projectId: 'suikagame-2dc1e',
        storageBucket: 'suikagame-2dc1e.firebasestorage.app',
        messagingSenderId: '96745545055',
        appId: '1:96745545055:web:9f5a8ad4bad5cf1240aaea',
        measurementId: 'G-3PQE9DEXGX',
      };
      firebase.initializeApp(firebaseConfig);
      const db = firebase.database();

      // Í∏∞Î≥∏
      const BASE_W = 360,
        BASE_H = 640;
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      function setupCanvasForDPR() {
        const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        canvas.width = Math.floor(BASE_W * dpr);
        canvas.height = Math.floor(BASE_H * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
      }
      setupCanvasForDPR();
      addEventListener('resize', setupCanvasForDPR);
      addEventListener('orientationchange', () =>
        setTimeout(setupCanvasForDPR, 100)
      );

      const scoreDiv = document.getElementById('score'),
        gameOverDiv = document.getElementById('gameOver');
      const rankingModal = document.getElementById('ranking-modal'),
        rankingOverlay = document.getElementById('ranking-overlay'),
        rankingList = document.getElementById('ranking-list'),
        modalCloseBtn = document.getElementById('modal-close');

      const dangerLine = BASE_H / 5;
      const nickname = localStorage.getItem('nickname') || 'ÏùµÎ™Ö';

      // Í≥ºÏùº
      const fruitData = [
        { name: 'cherry', radius: 20, score: 10 },
        { name: 'grape', radius: 44, score: 20 },
        { name: 'korean melon', radius: 69, score: 40 },
        { name: 'strawberry', radius: 85, score: 80 },
        { name: 'grape fruit', radius: 91, score: 160 },
        { name: 'watermelon', radius: 130, score: 320 },
      ];
      const charSet = localStorage.getItem('set') === 'B' ? 'yoon' : 'co';
      const fruitImages = {};
      let assetsLoaded = 0;
      fruitData.forEach((f) => {
        const img = new Image();
        img.src = `${f.name}_${charSet}.png`;
        img.onload = () => {
          if (++assetsLoaded === fruitData.length) startGame();
        };
        fruitImages[f.name] = img;
      });

      // ÏÉÅÌÉú
      let fruits = [],
        fallingFruit = null,
        gameOver = false,
        score = 0,
        rafId = null;

      // Î¨ºÎ¶¨
      const GRAVITY = 1200 / 3600,
        FIXED_DT = 1 / 60,
        SOLVER_ITERS = 8,
        RESTITUTION = 0.02,
        FRICTION = 0.05,
        SLEEP_SPEED = 5 / 60,
        SLEEP_TIME = 0.25,
        PENETRATION_SLOP = 0.5,
        POSITION_CORRECT = 0.6;
      const MERGE_HOLD_THRESHOLD = 0.05;
      let FRUIT_SEQ = 0;

      function createFruit(level, x, y) {
        const d = fruitData[level];
        return {
          id: FRUIT_SEQ++,
          x,
          y,
          vx: 0,
          vy: 0,
          radius: d.radius,
          level,
          alive: true,
          settled: false,
          sleepTimer: 0,
          mergeHold: 0,
        };
      }
      function wake(f) {
        f.settled = false;
        f.sleepTimer = 0;
      }
      function clampPosition(f) {
        f.x = Math.max(f.radius, Math.min(BASE_W - f.radius, f.x));
        f.y = Math.max(f.radius, Math.min(BASE_H - f.radius, f.y));
        if (f.settled && f.y + f.radius > BASE_H) f.y = BASE_H - f.radius;
      }

      // ===== ÏûÖÎ†•: ÎìúÎûòÍ∑∏Î°ú Ï°∞Ï§Ä, ÏÜê ÎñºÎ©¥ ÎìúÎ°≠ =====
      let controlPointerId = null;
      let isAiming = false;

      function getCanvasXFromEvent(e) {
        const rect = canvas.getBoundingClientRect();
        const x =
          (e.clientX ?? (e.touches && e.touches[0]?.clientX) ?? 0) - rect.left;
        return (x / rect.width) * BASE_W;
      }

      canvas.addEventListener(
        'pointerdown',
        (e) => {
          if (gameOver || !fallingFruit) return;
          // Ïù¥ Ìè¨Ïù∏ÌÑ∞Îßå Ï†úÏñ¥
          if (controlPointerId !== null) return;
          controlPointerId = e.pointerId;
          canvas.setPointerCapture?.(controlPointerId);
          isAiming = true;

          // ÌÑ∞Ïπò ÏãúÏûë ÏßÄÏ†êÏúºÎ°ú Ï¶âÏãú Ïä§ÎÉÖ (ÏùòÎèÑÏπò ÏïäÏùÄ Ïù¥Ï†Ñ ÏúÑÏπò ÎìúÎ°≠ Î∞©ÏßÄ)
          const r = fallingFruit.radius;
          const x = Math.max(r, Math.min(BASE_W - r, getCanvasXFromEvent(e)));
          fallingFruit.x = x;
          e.preventDefault();
        },
        { passive: false }
      );

      canvas.addEventListener(
        'pointermove',
        (e) => {
          if (
            !isAiming ||
            e.pointerId !== controlPointerId ||
            !fallingFruit ||
            gameOver
          )
            return;
          const r = fallingFruit.radius;
          const x = Math.max(r, Math.min(BASE_W - r, getCanvasXFromEvent(e)));
          fallingFruit.x = x;
          e.preventDefault();
        },
        { passive: false }
      );

      function commitDrop() {
        if (!fallingFruit || gameOver) return;
        fruits.push({ ...fallingFruit });
        fallingFruit = null;
        isAiming = false;
        if (controlPointerId !== null) {
          try {
            canvas.releasePointerCapture?.(controlPointerId);
          } catch {}
        }
        controlPointerId = null;
        spawnNext();
      }

      canvas.addEventListener(
        'pointerup',
        (e) => {
          if (e.pointerId !== controlPointerId) return;
          // ÏÜêÏùÑ ÎñºÎäî ÏàúÍ∞Ñ ÎìúÎ°≠
          commitDrop();
          e.preventDefault();
        },
        { passive: false }
      );

      canvas.addEventListener('pointercancel', (e) => {
        if (e.pointerId !== controlPointerId) return;
        // Ï∑®ÏÜåÎêòÏñ¥ÎèÑ ÎìúÎ°≠ Ï≤òÎ¶¨(ÏõêÌïòÎäî Í≤ΩÏö∞ Ï∑®ÏÜåÎ°ú Î¨¥ÏãúÌïòÎ†§Î©¥ return)
        commitDrop();
      });

      // iOS Î°±ÌîÑÎ†àÏä§ Î©îÎâ¥ Î∞©ÏßÄ
      canvas.addEventListener('contextmenu', (e) => e.preventDefault());
      document.addEventListener(
        'touchmove',
        (e) => {
          if (e.target === canvas) e.preventDefault();
        },
        { passive: false }
      );

      function spawnNext() {
        if (gameOver) return;
        const lvl = Math.floor(Math.random() * 2); // 0~1
        fallingFruit = createFruit(lvl, BASE_W / 2, 40);
      }

      // Î¨ºÎ¶¨ Ï≤òÎ¶¨
      function applyGravity(f) {
        if (!f.alive || f.settled) return;
        f.vy += GRAVITY;
        f.vx *= 0.985;
        f.vy *= 0.995;
      }
      function integrate(f) {
        if (!f.alive || f.settled) return;
        f.x += f.vx;
        f.y += f.vy;
      }
      function solveWalls(f) {
        if (!f.alive) return;
        if (f.x - f.radius < 0) {
          f.x = f.radius;
          f.vx = 0;
        } else if (f.x + f.radius > BASE_W) {
          f.x = BASE_W - f.radius;
          f.vx = 0;
        }
        if (f.y + f.radius > BASE_H) {
          const pen = f.y + f.radius - BASE_H;
          f.y -= pen;
          f.vy = -f.vy * RESTITUTION;
          f.vx *= 1 - FRICTION;
          if (Math.abs(f.vy) < SLEEP_SPEED) f.vy = 0;
          if (Math.abs(f.vx) < SLEEP_SPEED) f.vx = 0;
        }
        if (f.y - f.radius < 0) {
          f.y = f.radius;
          f.vy = 0;
        }
      }
      function solvePair(a, b) {
        if (!a.alive || !b.alive) return;
        const dx = b.x - a.x,
          dy = b.y - a.y,
          dist = Math.hypot(dx, dy),
          minDist = a.radius + b.radius;
        if (dist >= minDist) return;
        const nx = dx / (dist || 1),
          ny = dy / (dist || 1),
          tx = -ny,
          ty = nx;
        const rvx = b.vx - a.vx,
          rvy = b.vy - a.vy,
          vrelN = rvx * nx + rvy * ny,
          vrelT = rvx * tx + rvy * ty;
        let jn = (-(1 + RESTITUTION) * vrelN) / 2;
        if (jn < 0) jn = 0;
        let jt = -vrelT * FRICTION;
        a.vx -= jn * nx + jt * tx;
        a.vy -= jn * ny + jt * ty;
        b.vx += jn * nx + jt * tx;
        b.vy += jn * ny + jt * ty;
        const penetration = Math.max(0, minDist - dist - PENETRATION_SLOP),
          corr = (penetration * POSITION_CORRECT) / 2;
        a.x -= nx * corr;
        a.y -= ny * corr;
        b.x += nx * corr;
        b.y += ny * corr;
        wake(a);
        wake(b);
      }
      function updateSleep(f, dt) {
        if (!f.alive) return;
        const speed = Math.hypot(f.vx, f.vy);
        const onGround = f.y + f.radius >= BASE_H - 0.5;
        if (speed < SLEEP_SPEED && (onGround || f.settled)) {
          f.sleepTimer += dt;
          if (f.sleepTimer >= SLEEP_TIME) {
            f.vx = 0;
            f.vy = 0;
            f.settled = true;
          }
        } else {
          f.sleepTimer = 0;
          f.settled = false;
        }
      }

      // Ìï©Ï≤¥
      function isSameLevelInContact(a, b) {
        if (!a.alive || !b.alive) return false;
        if (a.level !== b.level) return false;
        const dx = b.x - a.x,
          dy = b.y - a.y,
          dist = Math.hypot(dx, dy),
          minDist = a.radius + b.radius;
        if (dist <= minDist - 0.25) return true;
        const relSpeed = Math.hypot(b.vx - a.vx, b.vy - a.vy);
        if (dist <= minDist + 0.6 && relSpeed < 6 / 60) return true;
        return false;
      }
      function updateMergeHolds(dt) {
        for (const f of fruits) {
          if (!f.alive) continue;
          f.mergeHold = Math.max(0, f.mergeHold - dt * 0.25);
        }
        for (let i = 0; i < fruits.length; i++) {
          const a = fruits[i];
          if (!a.alive) continue;
          for (let j = i + 1; j < fruits.length; j++) {
            const b = fruits[j];
            if (!b.alive) continue;
            if (isSameLevelInContact(a, b)) {
              a.mergeHold += dt;
              b.mergeHold += dt;
            }
          }
        }
      }
      function tryMergeAll() {
        let merged = false;
        outer: for (let i = 0; i < fruits.length; i++) {
          const a = fruits[i];
          if (!a.alive || a.mergeHold < MERGE_HOLD_THRESHOLD) continue;
          for (let j = i + 1; j < fruits.length; j++) {
            const b = fruits[j];
            if (!b.alive || b.mergeHold < MERGE_HOLD_THRESHOLD) continue;
            if (!isSameLevelInContact(a, b)) continue;
            if (a.level !== b.level) continue;
            if (a.level >= fruitData.length - 1) continue;
            const mx = (a.x + b.x) / 2,
              my = (a.y + b.y) / 2;
            const nf = createFruit(a.level + 1, mx, my);
            const overlap =
              a.radius + b.radius - Math.hypot(b.x - a.x, b.y - a.y);
            nf.y -= Math.max(0, overlap) * 0.25;
            nf.vx = (a.vx + b.vx) * 0.25;
            nf.vy = (a.vy + b.vy) * 0.25;
            clampPosition(nf);
            fruits.push(nf);
            score += fruitData[a.level + 1].score;
            scoreDiv.textContent = `Ï†êÏàò: ${score}`;
            a.alive = false;
            b.alive = false;
            merged = true;
            break outer;
          }
        }
        if (merged) fruits = fruits.filter((f) => f.alive);
      }

      // ÏúÑÌóòÏÑ†
      function isTouchingOthers(f, arr) {
        return arr.some(
          (o) =>
            o !== f &&
            o.alive &&
            Math.hypot(f.x - o.x, f.y - o.y) < f.radius + o.radius - 1
        );
      }
      function checkDangerLine() {
        return fruits.some(
          (f, _, arr) =>
            (f.settled || isTouchingOthers(f, arr)) &&
            f.y - f.radius < dangerLine + 0.5
        );
      }

      // Î†åÎçî
      function drawFruit(f) {
        const img = fruitImages[fruitData[f.level].name];
        if (img && img.complete) {
          ctx.drawImage(
            img,
            f.x - f.radius,
            f.y - f.radius,
            f.radius * 2,
            f.radius * 2
          );
        } else {
          ctx.beginPath();
          ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
          ctx.fillStyle = '#ff0';
          ctx.fill();
        }
      }

      // Î£®ÌîÑ
      let lastTime = performance.now(),
        acc = 0;
      function loop(now = performance.now()) {
        const elapsed = Math.min(0.1, (now - lastTime) / 1000);
        lastTime = now;
        acc += elapsed;
        while (acc >= FIXED_DT) {
          for (const f of fruits) applyGravity(f);
          for (const f of fruits) integrate(f);
          for (const f of fruits) solveWalls(f);
          for (let k = 0; k < SOLVER_ITERS; k++) {
            for (let i = 0; i < fruits.length; i++) {
              const a = fruits[i];
              if (!a.alive) continue;
              for (let j = i + 1; j < fruits.length; j++) {
                const b = fruits[j];
                if (!b.alive) continue;
                solvePair(a, b);
              }
            }
          }
          for (const f of fruits) updateSleep(f, FIXED_DT);
          updateMergeHolds(FIXED_DT);
          tryMergeAll();
          acc -= FIXED_DT;
        }

        ctx.clearRect(0, 0, BASE_W, BASE_H);
        ctx.save();
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, dangerLine);
        ctx.lineTo(BASE_W, dangerLine);
        ctx.stroke();
        ctx.restore();
        if (fallingFruit) {
          ctx.globalAlpha = 0.7;
          drawFruit(fallingFruit);
          ctx.globalAlpha = 1;
        }
        fruits.forEach(drawFruit);

        if (!gameOver) {
          if (checkDangerLine()) {
            gameOver = true;
            gameOverDiv.style.display = '';
            saveScoreToFirebase(score);
          } else {
            rafId = requestAnimationFrame(loop);
          }
        }
      }

      // Îû≠ÌÇπ
      function saveScoreToFirebase(score) {
        const ref = db.ref('records').push();
        ref
          .set({ name: nickname, score, timestamp: Date.now() })
          .then(showRankingModal)
          .catch(() => showRankingModal());
      }
      function showRankingModal() {
        db.ref('records')
          .orderByChild('score')
          .limitToLast(100)
          .once('value')
          .then((s) => {
            const raw = s.val();
            const data = raw ? Object.values(raw) : [];
            const sorted = data.sort((a, b) => b.score - a.score).slice(0, 5);
            rankingList.innerHTML = '';
            if (sorted.length === 0) {
              rankingList.innerHTML = '<li>Îû≠ÌÇπ Í∏∞Î°ù ÏóÜÏùå</li>';
            } else {
              sorted.forEach((r, i) => {
                const li = document.createElement('li');
                li.textContent = `${i + 1}ÏúÑ - ${r.name}: ${r.score}Ï†ê`;
                rankingList.appendChild(li);
              });
            }
            rankingOverlay.style.display = 'block';
            rankingModal.style.display = 'block';
          });
      }
      function closeModal(skipRestart = false) {
        rankingModal.style.display = 'none';
        rankingOverlay.style.display = 'none';
        if (!skipRestart) startGame();
      }
      rankingOverlay.addEventListener('click', () => closeModal());
      modalCloseBtn.addEventListener('click', () => closeModal());

      // ÏãúÏûë
      function spawnNext() {
        if (gameOver) return;
        const lvl = Math.floor(Math.random() * 2);
        fallingFruit = createFruit(lvl, BASE_W / 2, 40);
      }
      function startGame() {
        fruits = [];
        score = 0;
        gameOver = false;
        fallingFruit = null;
        scoreDiv.textContent = `Ï†êÏàò: ${score}`;
        gameOverDiv.style.display = 'none';
        rankingModal.style.display = 'none';
        rankingOverlay.style.display = 'none';
        spawnNext();
        if (rafId) cancelAnimationFrame(rafId);
        lastTime = performance.now();
        acc = 0;
        rafId = requestAnimationFrame(loop);
      }
    </script>
  </body>
</html>
